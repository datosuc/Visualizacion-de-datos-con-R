<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Visualizacion de datos con R: Shiny</title>
    <meta charset="utf-8" />
    <meta name="author" content="Joshua Kunst" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="assets/custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Visualizacion de datos con R: Shiny
## Diplomado en Data Science, MatPUC
### Joshua Kunst

---




class: center, middle, inverse

# Antes de Partir

---

# Antes de Partir

Asumimos que tenemos conocimiento de como funciona R, paquetes, funciones, etc.


No es necesario en `shiny` pero usaremos los paquetes `dplyr` y `ggplot` principalmente
para hacer manipulación y visualización de los datos


Necesitaremos algunos paquetes: 



```r
install.packages(
  c("tidyverse", "shiny", "shinythemes", "shinyWidgets",
    "shinydashboard", "DT", "leaflet", "plotly")
  )
```


La prestación podrá acceder desde https://github.com/datosuc/Visualizacion-de-datos-con-R y el código fuente,
apps, ejemplos en https://github.com/datosuc/Visualizacion-de-datos-con-R/tree/master/apps

---

# Ayuda


No olvidar que una buena forma de aprender es con la documentación oficial:


https://shiny.rstudio.com/tutorial/

https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/

https://github.com/rstudio/cheatsheets/raw/master/shiny.pdf

https://github.com/rstudio/cheatsheets/raw/master/translations/spanish/shiny_Spanish.pdf


---

class: center, middle, inverse

# ¿Qué es una __app__(licación) web?

---

# Aplicación Web

(Wikipedia:) Herramientas que los usuarios pueden utilizar accediendo 
a un servidor web a través de internet o de una intranet mediante un navegador.


![](imgs/miprimerapp.png)



---

# Aplicación Web

App con mas `input`s y `output`s

![](imgs/otraapp.png)


---

# La estructura de una ShinyApp

&lt;br&gt;


```r
library(shiny)

ui &lt;- fluidPage()

server &lt;- function(input, output) {}

runApp(list(ui = ui, server = server)) 
```

&lt;br&gt;

En `shiny`, una aplicación constará de **2** partes:

- La interfaz de usuario, `ui` (user interface), donde definiremos el look de nuestra aplicación, y lugar de  `inputs` y `outputs`.
- El `server`, en donde especificaremos como interactuan los `outputs` en función de los `inputs`.

---

# La estructura de una ShinyApp

&lt;br&gt;



```r
library(shiny)

*ui &lt;- fluidPage()

server &lt;- function(input, output) {}

runApp(list(ui = ui, server = server)) 
```


&lt;br&gt;

- Se define una interfaz de usuario (user interface). En adelante `ui`
- En este caso es una página fluida vacía `fluidPage()`.



- En el futuro acá definiremos diseño/estructura de nuestra aplicación (_layout_).
Que se refiere la disposición de nuestros `inputs` y `outputs`.



---

# La estructura de una ShinyApp

&lt;br&gt;


```r
library(shiny)

ui &lt;- fluidPage()                            

*server &lt;- function(input, output) {}

runApp(list(ui = ui, server = server)) 
```

&lt;br&gt;

- Se define el `server` en donde estará toda la lógica de nuestra aplicación.
- Principalmente serán instrucciones que dependeran de `inputs` y
reflejaremos `outputs`: como tablas, gráficos.


---

# La estructura de una ShinyApp

&lt;br&gt;


```r
library(shiny)

ui &lt;- fluidPage()                            

server &lt;- function(input, output) {}         

*runApp(list(ui = ui, server = server))
```

&lt;br&gt;

- `runApp` es la funcion que crea y deja corriendo la app con los 
parámetros otorgados.
- **No siempre** tendremos que escribirla pues veremos que RStudio
al crear una shinyApp nos pondrá un botón para _servir_ la aplicación.


---

class: center, middle, inverse

# Ejercicio #1

---

# Nuestra primer App andando

Hacer funcionar el siguiente `código` en R Rstudio: (hint: sí, copy + paste + run) 

.code70[

```r
library(shiny)

ui &lt;- fluidPage(
   sidebarLayout(
      sidebarPanel(
        sliderInput("nrand", "Simulaciones",
                    min = 50, max = 100, value = 70),
        selectInput("col", "Color", c("red", "blue", "black")),
        checkboxInput("punto", "Puntos:", value = FALSE)
      ),
      mainPanel(plotOutput("outplot"))
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({
     set.seed(123)
     x &lt;- rnorm(input$nrand)
     t &lt;- ifelse(input$punto, "b", "l")
     plot(x, type = t, col = input$col)
   })
}

shinyApp(ui, server)
```
]

---

class: center, middle, inverse

# Funcionamiento de una app de Shiny

---

# App

![](imgs/shiny_works/Diapositiva1.PNG)

---

# Contenedor 

![](imgs/shiny_works/Diapositiva2.PNG)

---

# Otros contenedores 

![](imgs/shiny_works/Diapositiva3.PNG)

---

# Inputs 

![](imgs/shiny_works/Diapositiva4.PNG)

---

# Outputs

![](imgs/shiny_works/Diapositiva5.PNG)

---

# Interacción 

![](imgs/shiny_works/Diapositiva6.PNG)

---

# Resultado

![](imgs/shiny_works/Diapositiva7.PNG)

---

# La estructura de una ShinyApp 2


.code60[

```r
ui &lt;- fluidPage(
   sidebarLayout(
      sidebarPanel(
        sliderInput("nrand", "Simulaciones",
                    min = 50, max = 100, value = 70),
        selectInput("col", "Color", c("red", "blue", "black")),
        checkboxInput("punto", "Puntos:", value = FALSE)
      ),
      mainPanel(plotOutput("outplot"))
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({
     set.seed(123)
     x &lt;- rnorm(input$nrand)
     t &lt;- ifelse(input$punto, "b", "l")
     plot(x, type = t, col = input$col)
   })
}
```
]

---

# La estructura de una ShinyApp 2

.code60[

```r
*ui &lt;- fluidPage(
*  sidebarLayout(
*     sidebarPanel(
        sliderInput("nrand", "Simulaciones",                       
                    min = 50, max = 100, value = 70),
        selectInput("col", "Color", c("red", "blue", "black")),
        checkboxInput("punto", "Puntos:", value = FALSE)
      ),
*     mainPanel(plotOutput("outplot"))
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({
     set.seed(123)
     x &lt;- rnorm(input$nrand)
     t &lt;- ifelse(input$punto, "b", "l")
     plot(x, type = t, col = input$col)
   })
}
```
]

- `fluidPage`, `sidebarLayout`, `sidebarPanel`, `mainPanel` definen el diseño/_layout_ de nuestra
app.
-  Existen muchas más formas de organizar una app: Por ejemplo uso de _tabs_ de _menus_, o páginas
con navegación. Más detalles http://shiny.rstudio.com/articles/layout-guide.html.


---

# La estructura de una ShinyApp 2

.code60[

```r
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
*       sliderInput("nrand", "Simulaciones",
*                   min = 50, max = 100, value = 70),
*       selectInput("col", "Color", c("red", "blue", "black")),
*       checkboxInput("punto", "Puntos:", value = FALSE)
      ),
      mainPanel(plotOutput("outplot"))                            
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({
     set.seed(123)
     x &lt;- rnorm(input$nrand)
     t &lt;- ifelse(input$punto, "b", "l")
     plot(x, type = t, col = input$col)
   })
}
```
]

- `sliderInput`, `selectInput`, `checkboxInput` son los inputs de nuestra app,
con esto el usuario puede interactuar con nuestra aplicación (https://shiny.rstudio.com/gallery/widget-gallery.html).
- Estas funciones generan el input deseado en la app y shiny perminte que los
valores de estos inputs sean usados como valores usuales en R en la parte del server
(numericos, strings, booleanos, fechas).

---

# La estructura de una ShinyApp 2

.code60[

```r
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
        sliderInput("nrand", "Simulaciones",                       
                    min = 50, max = 100, value = 70),             
        selectInput("col", "Color", c("red", "blue", "black")),   
        checkboxInput("punto", "Puntos:", value = FALSE)          
      ),
*     mainPanel(plotOutput("outplot"))
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({
     set.seed(123)
     x &lt;- rnorm(input$nrand)
     t &lt;- ifelse(input$punto, "b", "l")
     plot(x, type = t, col = input$col)
   })
}
```
]

- `plotOutput` define el lugar donde la salida estará.
- Como mencionamos, nuestras app ueden tener muchos outputs: tablas, texto, imágenes.


---

# La estructura de una ShinyApp 2

.code60[

```r
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
        sliderInput("nrand", "Simulaciones",                       
                    min = 50, max = 100, value = 70),             
        selectInput("col", "Color", c("red", "blue", "black")),   
        checkboxInput("punto", "Puntos:", value = FALSE)          
      ),
      mainPanel(plotOutput("outplot"))                                                   
   )
)

server &lt;- function(input, output) {
*  output$outplot &lt;- renderPlot({
     set.seed(123)
     x &lt;- rnorm(input$nrand)
     t &lt;- ifelse(input$punto, "b", "l")
     plot(x, type = t, col = input$col)
   })
}
```
]

- `renderPlot` define un tipo de salida gráfica.
- Existen otros tipos de salidas, como tablas `tableOutput` o tablas más interactivas como 
`DT::DTOutput`.


---

# La estructura de una ShinyApp 2

.code60[

```r
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
        sliderInput("nrand", "Simulaciones",                       
                    min = 50, max = 100, value = 70),             
        selectInput("col", "Color", c("red", "blue", "black")),   
        checkboxInput("punto", "Puntos:", value = FALSE)          
      ),
      mainPanel(plotOutput("outplot"))                                                   
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({                               
*    set.seed(123)
*    x &lt;- rnorm(input$nrand)
*    t &lt;- ifelse(input$punto, "b", "l")
*    plot(x, type = t, col = input$col)
   })
}
```
]

- Este espacio determina la lógica de nuestra salida.
- Acá haremos uso de los inputs para entregar lo que deseamos.


---

class: center, middle, inverse

# Interacción entre inputs y outputs

---

# La estructura de una ShinyApp 2

.code60[
&lt;pre class="r hljs remark-code"&gt;
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
        sliderInput("nrand", "Simulaciones",                       
                    min = 50, max = 100, value = 70),             
        selectInput("col", "Color", c("red", "blue", "black")),   
        checkboxInput("punto", "Puntos:", value = FALSE)          
      ),
      mainPanel(&lt;b&gt;plotOutput&lt;/b&gt;("outplot"))
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- &lt;b&gt;renderPlot&lt;/b&gt;({                               
     set.seed(123)                                              
     x &lt;- rnorm(input$nrand)                                    
     t &lt;- ifelse(input$punto, "b", "l")                         
     plot(x, type = t, col = input$col)                         
   })
}
&lt;/pre&gt;
]

- Las funciones `*Output()` y `render*()`  trabajan juntas para agregar salidas de R a la
interfaz de usuario
- En este caso `renderPlot` esta asociado con `plotOutput` (¿cómo?)
- Hay muchas parejas como `renderText`/`textOutput` o `renderTable`/`tableOutput` entre
otras (revisar la sección de outputs en el cheat sheet)
 
 
---

# La estructura de una ShinyApp 2

.code60[
&lt;pre class="r hljs remark-code"&gt;
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
        sliderInput("nrand", "Simulaciones",                       
                    min = 50, max = 100, value = 70),             
        selectInput("col", "Color", c("red", "blue", "black")),   
        checkboxInput("punto", "Puntos:", value = FALSE)          
      ),
      mainPanel(plotOutput(&lt;b&gt;"outplot"&lt;/b&gt;))
   )
)

server &lt;- function(input, output) {
   output$&lt;b&gt;outplot&lt;/b&gt; &lt;- renderPlot({                               
     set.seed(123)                                              
     x &lt;- rnorm(input$nrand)                                    
     t &lt;- ifelse(input$punto, "b", "l")                         
     plot(x, type = t, col = input$col)                         
   })
}
&lt;/pre&gt;
]

- Cada `*Output()` y `render*()` se asocian con un **id** definido por nosotros
- Este **id** debe ser único en la applicación
- En el ejemplo `renderPlot` esta asociado con `plotOutput` vía el id `outplot`

---

# La estructura de una ShinyApp 2

.code60[
&lt;pre class="r hljs remark-code"&gt;
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
        sliderInput(&lt;b&gt;"nrand"&lt;/b&gt;, "Simulaciones",                       
                    min = 50, max = 100, value = 70),             
        selectInput("col", "Color", c("red", "blue", "black")),   
        checkboxInput("punto", "Puntos:", value = FALSE)          
      ),
      mainPanel(plotOutput("outplot"))
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({                               
     set.seed(123)                                              
     x &lt;- rnorm(input$&lt;b&gt;nrand&lt;/b&gt;)                                    
     t &lt;- ifelse(input$punto, "b", "l")                         
     plot(x, type = t, col = input$col)                         
   })
}
&lt;/pre&gt;
]

- Cada functión `*Input` requiere un **id** para ser identificado en el server
- Cada `*Input` requiere argumentos especificos a cada tipo de input, valor por defecto,
etiquetas, opciones, rangos, etc
- Acá, el valor númerico ingresado/modifcado por el usuario se puede 
acceder en el server bajo `input$nrand`


---

# La estructura de una ShinyApp 2

.code60[
&lt;pre class="r hljs remark-code"&gt;
ui &lt;- fluidPage(                                                                                          
   sidebarLayout(                                                 
      sidebarPanel(                                               
        sliderInput(&lt;b&gt;"nrand"&lt;/b&gt;, "Simulaciones",                       
                    min = 50, max = 100, value = 70),             
        selectInput(&lt;b&gt;"col"&lt;/b&gt;, "Color", c("red", "blue", "black")),   
        checkboxInput(&lt;b&gt;"punto"&lt;/b&gt;, "Puntos:", value = FALSE)          
      ),
      mainPanel(plotOutput("outplot"))
   )
)

server &lt;- function(input, output) {
   output$outplot &lt;- renderPlot({                               
     set.seed(123)                                              
     x &lt;- rnorm(input$&lt;b&gt;nrand&lt;/b&gt;)                                    
     t &lt;- ifelse(input$&lt;b&gt;punto&lt;/b&gt;, "b", "l")                         
     plot(x, type = t, col = input$&lt;b&gt;col&lt;/b&gt;)                         
   })
}
&lt;/pre&gt;
]

- `sliderInput` se usa para seleccionar un valor numérico entre un rango 
- `selectInput` otorga la posibildad que el usuario escoge entre un conjunto de valores
- `checkboxInput` en el server es un valor lógico `TRUE`/`FALSE`
- ¿Necesitas más? https://gallery.shinyapps.io/065-update-input-demo/ y http://shinyapps.dreamrs.fr/shinyWidgets/ 


---

class: center, middle, inverse

# Ejercicio #2


---

# Inputs y outputs vengan a mi!


Haga click en:

- _File_, luego _New File_ y _Shiny Web App_, seleccione el nombre
- Ejecutela con _Run App_ e intearctúe
- Luego modifique y cree una app que contenga:
  - 2 inputs, un `sliderInput` y un `textInput` 
  - 3 output de tipo texto `textOutput` donde el primer contenga 
el valor del primer input, el segundo el valor del segundo input, y el tercero la suma de los
dos inputs


Hints importantes:

- No tema a escribir, ni preguntar!
- Está totalmente permitido equivocarse, de hecho se pondrán puntos extras
- Posible solución estará en https://github.com/datosuc/Visualizacion-de-datos-con-R/blob/master/apps/02-ejercicio-2/app.R


---

class: center, middle, inverse

# Layouts, HTMLWidgets y Diseño

---

# Tipos de Layouts


Dependiendo de las necesidaes puede ser convenientes algunos
tipos de layuts sobre otros

Recorreremos algunos más comunes


---

# sidebarLayout

El más usuado, generalmente los inputs están agrupados a mano izquierda y 


```r
library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello Shiny!"),
  sidebarLayout(
    sidebarPanel(
      sliderInput("obs", "Number of observations:", min = 0, max = 1000, value = 500)
    ),
    mainPanel(plotOutput("distPlot"))
  )
)

server &lt;- function(input, output) {
  output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) })
}

shinyApp(ui, server)
```

---

# sidebarLayout

El más usuado, generalmente los inputs están agrupados a mano izquierda y 

![](imgs/sidebar.png)


---

# tabsetPanel

Los tabs son útiles para separar secciones en nuestra app

.code70[

```r
library(shiny)

ui &lt;- fluidPage(
  titlePanel("Hello Shiny!"),
  sidebarLayout(
    sidebarPanel(
      sliderInput("obs", "Number of observations:", min = 0, max = 1000, value = 500)
    ),
    mainPanel(
      tabsetPanel(
        tabPanel("Plot", plotOutput("plot")),
        tabPanel("Summary", verbatimTextOutput("summary")),
        tabPanel("Table", tableOutput("tabla"))
      )
    )
  )
)
inf
server &lt;- function(input, output) {
  output$plot &lt;- renderPlot({ hist(rnorm(input$obs)) })
  output$summary &lt;- renderText({ input$obs })
  output$tabla &lt;- renderTable({ data.frame(input$obs) })
}

shinyApp(ui, server)
```
]

---

# tabsetPanel

Los tabs son útiles para separar secciones en nuestra app 

![](imgs/tabs.png)


---

# HTMLWidgets

&lt;br&gt;

- HTMLWidgets son un tipo de paquetes que nos permiten realizar visualizaciones en HTML
las cuales son fácil de integrar con shiny
- Existen una gran cantida de paquetes https://gallery.htmlwidgets.org/


---

# Mas opciones de interfaces


&lt;br&gt;

- https://rstudio.github.io/shinydashboard/
- https://rinterface.com/

---

class: center, middle, inverse

# Ejercicio #3 y #3version2

---

# Transformando script R en una App

&lt;br&gt;

- Inspeccionar, ejecutar y modificar el script https://github.com/datosuc/Visualizacion-de-datos-con-R/blob/master/apps/script-export.R (la siguiente slide tambien lo tiene).
- Generar una app que tenga como input una lista de países y
muestre el forecast de las exportaciones de dicho país.

---

# Código

.code70[

```r
if(!require(forecast)) install.packages("forecast")
if(!require(xts)) install.packages("xts")
if(!require(tradestatistics)) install.packages("tradestatistics")
if(!require(ggplot2)) install.packages("ggplot2")

library(forecast)
library(xts)
library(tradestatistics)
library(ggplot2)

pais &lt;- "chn"  # seteo pais

data &lt;- ots_create_tidy_data(years = 1990:2018, reporters = pais, table = "yr")

valores &lt;- data$export_value_usd
fechas &lt;- as.Date(paste0(data$year, "0101"), format = "%Y%m%d",)

serie &lt;- xts(valores, order.by = fechas) # creo la serie de tiempo para la fucion forecast

prediccion &lt;- forecast(serie, h = 5) # realizo automágicamente una predicción

# IMPORTANTE: estas predicciones no *son las mas mejores* la idea  
# del ejercicio es imaginar que tenemos un proceso el 
# cual transformaremos en una app
autoplot(prediccion)
```
]

---

# Transformando script R en una App 2

&lt;br&gt;

- Inspeccionar, ejecutar y modificar el script https://github.com/datosuc/Visualizacion-de-datos-con-R/blob/master/apps/script-export-2.R (la siguiente slide tambien lo tiene).
- Generar una app que tenga como input una lista de indicadores y selector de fechas y
generar el gráfico.
- Utilice tabs para mostrar información adicional como resumentes por año.
- Utilizar `shinywidgets` para agregar otras opciones para el usuario.

---

# Código

.code70[

```r
if(!require(tidyverse)) install.packages("tidyverse")
if(!require(mindicador)) install.packages("mindicador")
if(!require(highcharter)) install.packages("highcharter")
if(!require(DT)) install.packages("DT")

library(tidyverse)
library(lubridate)
library(ggplot2)

d &lt;- mindicador::mindicador_importar_datos("uf", anios = 2015:2020)

hchart(d, "line", hcaes(fecha, valor))

d %&gt;% 
  group_by(year(fecha)) %&gt;% 
  summarise(valor_mean = mean(valor)) %&gt;% 
  DT::datatable()
```
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
